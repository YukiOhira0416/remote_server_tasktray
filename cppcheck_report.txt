Checking DebugLog.cpp ...
1/11 files checked 1% done
Checking DisplayManager.cpp ...
2/11 files checked 12% done
Checking GPUManager.cpp ...
3/11 files checked 16% done
Checking Globals.cpp ...
4/11 files checked 16% done
Checking OverlayManager.cpp ...
5/11 files checked 29% done
Checking RegistryHelper.cpp ...
6/11 files checked 40% done
Checking SharedMemoryHelper.cpp ...
7/11 files checked 55% done
Checking StringConversion.cpp ...
8/11 files checked 55% done
Checking TaskTrayApp.cpp ...
9/11 files checked 87% done
Checking Utility.cpp ...
10/11 files checked 89% done
Checking remote_server_tasktray.cpp ...
11/11 files checked 100% done
 TaskTrayApp.h:13:5: style: Class 'TaskTrayApp' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    TaskTrayApp(HINSTANCE hInstance);
    ^
SharedMemoryHelper.h:12:5: style: Class 'SharedMemoryHelper' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SharedMemoryHelper(TaskTrayApp* app);
    ^
DisplayManager.cpp:28:58: style: C-style pointer casting [cstyleCast]
    if (FAILED(CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory))) {
                                                         ^
DisplayManager.cpp:152:58: style: C-style pointer casting [cstyleCast]
    if (FAILED(CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory))) {
                                                         ^
GPUManager.cpp:40:63: style: C-style pointer casting [cstyleCast]
    hr = pDevice->QueryInterface(__uuidof(ID3D11VideoDevice), (void**)&pVideoDevice);
                                                              ^
GPUManager.cpp:57:58: style: C-style pointer casting [cstyleCast]
    if (FAILED(CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory))) {
                                                         ^
GPUManager.cpp:93:5: style: Consider using std::all_of or std::none_of algorithm instead of a raw loop. [useStlAlgorithm]
    for (const auto& gpu : gpus) {
    ^
OverlayManager.h:32:10: performance: inconclusive: Technically the member function 'OverlayManager::ResolveMonitorInfoBySerial' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool ResolveMonitorInfoBySerial(const std::string& serialUtf8, RECT& outRect, HMONITOR& outMon, UINT& outDpi);
         ^
OverlayManager.cpp:91:22: note: Technically the member function 'OverlayManager::ResolveMonitorInfoBySerial' can be static (but you may consider moving to unnamed namespace).
bool OverlayManager::ResolveMonitorInfoBySerial(const std::string& serialUtf8, RECT& outRect, HMONITOR& outMon, UINT& outDpi) {
                     ^
OverlayManager.h:32:10: note: Technically the member function 'OverlayManager::ResolveMonitorInfoBySerial' can be static (but you may consider moving to unnamed namespace).
    bool ResolveMonitorInfoBySerial(const std::string& serialUtf8, RECT& outRect, HMONITOR& outMon, UINT& outDpi);
         ^
OverlayManager.h:36:10: performance: inconclusive: Technically the member function 'OverlayManager::DrawOverlayContent' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void DrawOverlayContent(HDC hdc, const RECT& clientRect, int number, UINT dpi);
         ^
OverlayManager.cpp:236:22: note: Technically the member function 'OverlayManager::DrawOverlayContent' can be static (but you may consider moving to unnamed namespace).
void OverlayManager::DrawOverlayContent(HDC hdc, const RECT& clientRect, int number, UINT dpi) {
                     ^
OverlayManager.h:36:10: note: Technically the member function 'OverlayManager::DrawOverlayContent' can be static (but you may consider moving to unnamed namespace).
    void DrawOverlayContent(HDC hdc, const RECT& clientRect, int number, UINT dpi);
         ^
OverlayManager.cpp:115:58: style: C-style pointer casting [cstyleCast]
    if (FAILED(CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory))) {
                                                         ^
RegistryHelper.cpp:21:57: style: C-style pointer casting [cstyleCast]
        if (RegSetValueEx(hKey, L"VendorID", 0, REG_SZ, (BYTE*)wVendorID.c_str(), static_cast<DWORD>((wVendorID.size() + 1) * sizeof(wchar_t))) != ERROR_SUCCESS) {
                                                        ^
RegistryHelper.cpp:26:57: style: C-style pointer casting [cstyleCast]
        if (RegSetValueEx(hKey, L"DeviceID", 0, REG_SZ, (BYTE*)wDeviceID.c_str(), static_cast<DWORD>((wDeviceID.size() + 1) * sizeof(wchar_t))) != ERROR_SUCCESS) {
                                                        ^
RegistryHelper.cpp:79:61: style: C-style pointer casting [cstyleCast]
        if (RegSetValueEx(hKey, keyName.c_str(), 0, REG_SZ, (BYTE*)wSerial.c_str(), static_cast<DWORD>((wSerial.size() + 1) * sizeof(wchar_t))) != ERROR_SUCCESS) {
                                                            ^
RegistryHelper.cpp:138:63: style: C-style pointer casting [cstyleCast]
        if (RegSetValueEx(hKey, L"SelectedSerial", 0, REG_SZ, (BYTE*)wSerial.c_str(), static_cast<DWORD>((wSerial.size() + 1) * sizeof(wchar_t))) != ERROR_SUCCESS) {
                                                              ^
SharedMemoryHelper.h:14:17: performance: inconclusive: Technically the member function 'SharedMemoryHelper::ReadSharedMemory' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string ReadSharedMemory(const std::string& name);
                ^
SharedMemoryHelper.cpp:168:33: note: Technically the member function 'SharedMemoryHelper::ReadSharedMemory' can be static (but you may consider moving to unnamed namespace).
std::string SharedMemoryHelper::ReadSharedMemory(const std::string& name) {
                                ^
SharedMemoryHelper.h:14:17: note: Technically the member function 'SharedMemoryHelper::ReadSharedMemory' can be static (but you may consider moving to unnamed namespace).
    std::string ReadSharedMemory(const std::string& name);
                ^
SharedMemoryHelper.h:16:10: performance: inconclusive: Technically the member function 'SharedMemoryHelper::DeleteSharedMemory' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool DeleteSharedMemory(); // メソッドの宣言を追加
         ^
SharedMemoryHelper.cpp:297:26: note: Technically the member function 'SharedMemoryHelper::DeleteSharedMemory' can be static (but you may consider moving to unnamed namespace).
bool SharedMemoryHelper::DeleteSharedMemory() {
                         ^
SharedMemoryHelper.h:16:10: note: Technically the member function 'SharedMemoryHelper::DeleteSharedMemory' can be static (but you may consider moving to unnamed namespace).
    bool DeleteSharedMemory(); // メソッドの宣言を追加
         ^
SharedMemoryHelper.h:17:10: performance: inconclusive: Technically the member function 'SharedMemoryHelper::DeleteEvent' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool DeleteEvent();
         ^
SharedMemoryHelper.cpp:303:26: note: Technically the member function 'SharedMemoryHelper::DeleteEvent' can be static (but you may consider moving to unnamed namespace).
bool SharedMemoryHelper::DeleteEvent() {
                         ^
SharedMemoryHelper.h:17:10: note: Technically the member function 'SharedMemoryHelper::DeleteEvent' can be static (but you may consider moving to unnamed namespace).
    bool DeleteEvent();
         ^
TaskTrayApp.h:15:9: performance: inconclusive: Technically the member function 'TaskTrayApp::Run' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int Run();
        ^
TaskTrayApp.cpp:595:18: note: Technically the member function 'TaskTrayApp::Run' can be static (but you may consider moving to unnamed namespace).
int TaskTrayApp::Run() {
                 ^
TaskTrayApp.h:15:9: note: Technically the member function 'TaskTrayApp::Run' can be static (but you may consider moving to unnamed namespace).
    int Run();
        ^
TaskTrayApp.cpp:370:33: style: Condition 'app->Cleanup()' is always true [knownConditionTrueFalse]
                if (app->Cleanup()) {
                                ^
TaskTrayApp.cpp:370:33: note: Calling function 'Cleanup' returns 1
                if (app->Cleanup()) {
                                ^
TaskTrayApp.cpp:370:33: note: Condition 'app->Cleanup()' is always true
                if (app->Cleanup()) {
                                ^
TaskTrayApp.cpp:38:36: style: inconclusive: Function 'TaskTrayApp' argument 1 names different: declaration 'hInstance' definition 'hInst'. [funcArgNamesDifferent]
TaskTrayApp::TaskTrayApp(HINSTANCE hInst) : hInstance(hInst), hwnd(NULL), running(true) {
                                   ^
TaskTrayApp.h:13:27: note: Function 'TaskTrayApp' argument 1 names different: declaration 'hInstance' definition 'hInst'.
    TaskTrayApp(HINSTANCE hInstance);
                          ^
TaskTrayApp.cpp:38:36: note: Function 'TaskTrayApp' argument 1 names different: declaration 'hInstance' definition 'hInst'.
TaskTrayApp::TaskTrayApp(HINSTANCE hInst) : hInstance(hInst), hwnd(NULL), running(true) {
                                   ^
TaskTrayApp.cpp:433:31: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            newDisplaySerials.push_back(display.serialNumber);
                              ^
TaskTrayApp.cpp:451:65: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                if (display.serialNumber == lastSelectedSerial) {
                                                                ^
TaskTrayApp.cpp:463:40: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]
                if (display.isPrimary) {
                                       ^
TaskTrayApp.cpp:550:62: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
            if (display.serialNumber == systemPrimarySerial) {
                                                             ^
remote_server_tasktray.cpp:19:60: style: C-style pointer casting [cstyleCast]
    HRESULT hr = CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory);
                                                           ^
remote_server_tasktray.cpp:72:46: style: C-style pointer casting [cstyleCast]
        auto setProcessDpiAwarenessContext = (SetProcessDpiAwarenessContext_t)GetProcAddress(user32, "SetProcessDpiAwarenessContext");
                                             ^
remote_server_tasktray.cpp:121:14: style: Local variable 'gpus' shadows outer variable [shadowVariable]
        auto gpus = GPUManager::GetInstalledGPUs();
             ^
remote_server_tasktray.cpp:92:10: note: Shadowed declaration
    auto gpus = GPUManager::GetInstalledGPUs();
         ^
remote_server_tasktray.cpp:121:14: note: Shadow variable
        auto gpus = GPUManager::GetInstalledGPUs();
             ^
remote_server_tasktray.cpp:123:21: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            onlyGPU = gpu;
                    ^
remote_server_tasktray.cpp:66:0: style: The function 'WinMain' is never used. [unusedFunction]
int APIENTRY WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow) {
^
nofile:0:0: information: Active checkers: 174/592 (use --checkers-report=<filename> to see details) [checkersReport]
