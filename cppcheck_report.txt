TaskTrayApp.h:13:5: style: Class 'TaskTrayApp' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    TaskTrayApp(HINSTANCE hInstance);
    ^
SharedMemoryHelper.h:12:5: style: Class 'SharedMemoryHelper' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SharedMemoryHelper(TaskTrayApp* app);
    ^
DisplayManager.cpp:29:58: style: C-style pointer casting [cstyleCast]
    if (FAILED(CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory))) {
                                                         ^
DisplayManager.cpp:173:58: style: C-style pointer casting [cstyleCast]
    if (FAILED(CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory))) {
                                                         ^
GPUManager.cpp:40:63: style: C-style pointer casting [cstyleCast]
    hr = pDevice->QueryInterface(__uuidof(ID3D11VideoDevice), (void**)&pVideoDevice);
                                                              ^
GPUManager.cpp:57:58: style: C-style pointer casting [cstyleCast]
    if (FAILED(CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&pFactory))) {
                                                         ^
GPUManager.cpp:93:5: style: Consider using std::all_of or std::none_of algorithm instead of a raw loop. [useStlAlgorithm]
    for (const auto& gpu : gpus) {
    ^
RegistryHelper.cpp:19:57: style: C-style pointer casting [cstyleCast]
        if (RegSetValueEx(hKey, L"VendorID", 0, REG_SZ, (BYTE*)wVendorID.c_str(), static_cast<DWORD>((wVendorID.size() + 1) * sizeof(wchar_t))) != ERROR_SUCCESS) {
                                                        ^
RegistryHelper.cpp:24:57: style: C-style pointer casting [cstyleCast]
        if (RegSetValueEx(hKey, L"DeviceID", 0, REG_SZ, (BYTE*)wDeviceID.c_str(), static_cast<DWORD>((wDeviceID.size() + 1) * sizeof(wchar_t))) != ERROR_SUCCESS) {
                                                        ^
RegistryHelper.cpp:79:61: style: C-style pointer casting [cstyleCast]
        if (RegSetValueEx(hKey, keyName.c_str(), 0, REG_SZ, (BYTE*)wDISPInfo.c_str(), static_cast<DWORD>((wDISPInfo.size() + 1) * sizeof(wchar_t))) != ERROR_SUCCESS) {
                                                            ^
RegistryHelper.cpp:132:63: style: C-style pointer casting [cstyleCast]
        if (RegSetValueEx(hKey, L"SelectedSerial", 0, REG_SZ, (BYTE*)wSerial.c_str(),
                                                              ^
RegistryHelper.cpp:68:65: style: inconclusive: Function 'WriteDISPInfoToRegistry' argument 1 names different: declaration 'DispInfo' definition 'DISPInfo'. [funcArgNamesDifferent]
bool RegistryHelper::WriteDISPInfoToRegistry(const std::string& DISPInfo) {
                                                                ^
RegistryHelper.h:12:60: note: Function 'WriteDISPInfoToRegistry' argument 1 names different: declaration 'DispInfo' definition 'DISPInfo'.
    static bool WriteDISPInfoToRegistry(const std::string& DispInfo);
                                                           ^
RegistryHelper.cpp:68:65: note: Function 'WriteDISPInfoToRegistry' argument 1 names different: declaration 'DispInfo' definition 'DISPInfo'.
bool RegistryHelper::WriteDISPInfoToRegistry(const std::string& DISPInfo) {
                                                                ^
SharedMemoryHelper.h:14:17: performance: inconclusive: Technically the member function 'SharedMemoryHelper::ReadSharedMemory' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string ReadSharedMemory(const std::string& name);
                ^
SharedMemoryHelper.cpp:168:33: note: Technically the member function 'SharedMemoryHelper::ReadSharedMemory' can be static (but you may consider moving to unnamed namespace).
std::string SharedMemoryHelper::ReadSharedMemory(const std::string& name) {
                                ^
SharedMemoryHelper.h:14:17: note: Technically the member function 'SharedMemoryHelper::ReadSharedMemory' can be static (but you may consider moving to unnamed namespace).
    std::string ReadSharedMemory(const std::string& name);
                ^
SharedMemoryHelper.h:16:10: performance: inconclusive: Technically the member function 'SharedMemoryHelper::DeleteSharedMemory' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool DeleteSharedMemory(); // メソッドの宣言を追加
         ^
SharedMemoryHelper.cpp:297:26: note: Technically the member function 'SharedMemoryHelper::DeleteSharedMemory' can be static (but you may consider moving to unnamed namespace).
bool SharedMemoryHelper::DeleteSharedMemory() {
                         ^
SharedMemoryHelper.h:16:10: note: Technically the member function 'SharedMemoryHelper::DeleteSharedMemory' can be static (but you may consider moving to unnamed namespace).
    bool DeleteSharedMemory(); // メソッドの宣言を追加
         ^
SharedMemoryHelper.h:17:10: performance: inconclusive: Technically the member function 'SharedMemoryHelper::DeleteEvent' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool DeleteEvent();
         ^
SharedMemoryHelper.cpp:303:26: note: Technically the member function 'SharedMemoryHelper::DeleteEvent' can be static (but you may consider moving to unnamed namespace).
bool SharedMemoryHelper::DeleteEvent() {
                         ^
SharedMemoryHelper.h:17:10: note: Technically the member function 'SharedMemoryHelper::DeleteEvent' can be static (but you may consider moving to unnamed namespace).
    bool DeleteEvent();
         ^
TaskTrayApp.h:15:9: performance: inconclusive: Technically the member function 'TaskTrayApp::Run' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int Run();
        ^
TaskTrayApp.cpp:550:18: note: Technically the member function 'TaskTrayApp::Run' can be static (but you may consider moving to unnamed namespace).
int TaskTrayApp::Run() {
                 ^
TaskTrayApp.h:15:9: note: Technically the member function 'TaskTrayApp::Run' can be static (but you may consider moving to unnamed namespace).
    int Run();
        ^
TaskTrayApp.cpp:297:21: style: Condition 'cleanupResult' is always true [knownConditionTrueFalse]
                if (cleanupResult) {
                    ^
TaskTrayApp.cpp:296:45: note: Calling function 'Cleanup' returns 1
                cleanupResult = app->Cleanup();
                                            ^
TaskTrayApp.cpp:296:45: note: Assignment 'cleanupResult=app->Cleanup()', assigned value is 1
                cleanupResult = app->Cleanup();
                                            ^
TaskTrayApp.cpp:297:21: note: Condition 'cleanupResult' is always true
                if (cleanupResult) {
                    ^
TaskTrayApp.cpp:271:14: style: The scope of the variable 'cleanupResult' can be reduced. [variableScope]
        bool cleanupResult = false; // 初期化
             ^
TaskTrayApp.cpp:32:36: style: inconclusive: Function 'TaskTrayApp' argument 1 names different: declaration 'hInstance' definition 'hInst'. [funcArgNamesDifferent]
TaskTrayApp::TaskTrayApp(HINSTANCE hInst) : hInstance(hInst), hwnd(NULL), running(true) {
                                   ^
TaskTrayApp.h:13:27: note: Function 'TaskTrayApp' argument 1 names different: declaration 'hInstance' definition 'hInst'.
    TaskTrayApp(HINSTANCE hInstance);
                          ^
TaskTrayApp.cpp:32:36: note: Function 'TaskTrayApp' argument 1 names different: declaration 'hInstance' definition 'hInst'.
TaskTrayApp::TaskTrayApp(HINSTANCE hInst) : hInstance(hInst), hwnd(NULL), running(true) {
                                   ^
TaskTrayApp.cpp:351:30: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]
            if (d.isPrimary) { currentPrimarySerial = d.serialNumber; break; }
                             ^
TaskTrayApp.cpp:409:70: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]
                for (const auto& d : NewDisplays) { if (d.isPrimary) { newSel = d.serialNumber; break; } }
                                                                     ^
TaskTrayApp.cpp:492:40: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                if (s == persistedSel) { persistedSelOk = true; break; }
                                       ^
TaskTrayApp.cpp:502:34: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]
                if (d.isPrimary) {
                                 ^
remote_server_tasktray.cpp:18:23: style: C-style pointer casting [cstyleCast]
        SetCtx pSet = (SetCtx)GetProcAddress(GetModuleHandleW(L"user32.dll"), "SetProcessDpiAwarenessContext");
                      ^
remote_server_tasktray.cpp:41:17: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
        onlyGPU = gpu;
                ^
DisplayManager.cpp:215:0: style: The function 'GetDisplaysForGPU' is never used. [unusedFunction]
std::vector<DisplayInfo> DisplayManager::GetDisplaysForGPU(const std::string& gpuVendorID, const std::string& gpuDeviceID) {
^
remote_server_tasktray.cpp:12:0: style: The function 'WinMain' is never used. [unusedFunction]
int APIENTRY WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow) {
^
nofile:0:0: information: Active checkers: 174/592 (use --checkers-report=<filename> to see details) [checkersReport]
